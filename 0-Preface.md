# 前言

您好！

您大概都曾经问过自己至少一次，操作系统到底是怎么从头开始写出来的。也许您已经有了数年的开发经验，然而对于操作系统的理解仍然停留在一系列抽象概念，而非实际的实现上。对于那些从来没有构建过操作系统的人，操作系统就像是魔法：它可以很神奇地控制硬件，同时通过程序员最喜欢的编程语言API处理他们的请求。学习如何构建一个操作系统听上去非常困难；无论学了多少东西，您总会觉得懂的还不够多。您现在读这本书，大概是为了更深入了解操作系统，从而成为更好的软件工程师吧。

如果是这样，那这本书就是为您准备的。阅读本书，您将会补齐所有缺失的知识，使得您可以从头开始实现您自己的操作系统！是的，从头开始，无需贯通任何已有的操作系统来证明您是一位操作系统工程师。您也许会问，“学习Linux内核不是更实际一些么？”

是的。。。

也不是。

学习Linux会对您的日常工作有帮助。然而如果选择这条路，您仍然无法达成终极目标：写一个实际的操作系统。通过编写您自己的操作系统，您会获得更多的知识，而只学习Linux是无法获得这些知识的。

下面是编写您自己的操作系统的一些好处：

- 您将会学习计算机在硬件层面是如何工作的，也会学习编写软件来直接管理硬件。
- 您将会学习操作系统的基础知识，从而可以应付任何操作系统，而不只是Linux。
- 为了恰当地黑进Linux内核，您也需要独立编写至少一个操作系统。这就好像应用编程一样：写一个大型应用之前，您需要从简单的应用开始写起。
- 您将会打开通向各种底层开发领域的大门，例如反向工程、漏洞利用、构建虚拟机、游戏主机模拟等等。汇编语言将成为您最不可或缺的底层分析工具之一。（但是这不意味着您必须用汇编语言编写您的操作系统！）
- 写一个操作系统很有意思

## 为什么要写另一本关于操作系统的书？

许多有名的教授和专家已经在这个话题上写了许多书，准备了许多课程。我又何德何能要在这个进阶话题上写一本书呢？确实，市面上已经有很多优质的学习材料，然而我觉得还是不够。它们有告诉您不依赖一个已有操作系统如何编译您的C语言代码以及C运行时库吗？绝大部分关于操作系统设计与实现的书籍只讨论了软件这一块；操作系统是如何与硬件通信的这一部分都被略去了。重要的硬件细节的忽略，使得一个自学者在网上很难找到相关的资料。本书的目标是填平这个鸿沟：您将不只是学习如何直接对硬件编程，而且还会学习如何阅读来自硬件厂商的官方文档来编程。您不再需要寻找各种资料来帮您解读硬件手册和文档：您可以自己动手。最后，我是从自学者的角度来写这本书的。我会让本书尽可能的完备，从而您可以把更多的时间放在学习上，而不是去猜或是到网上去寻找信息。

本书的着重点之一是对您在阅读厂商官方文档，从而实现您的软件的整个过程中给与指导。来自诸如Intel这样的硬件厂商的官方文档对于实现一个操作系统，或是其他直接控制硬件的软件来说至关重要。至少，操作系统开发人员需要能够理解这些文档，并基于一套硬件规范开发软件。因此，第一章致力于讨论这些相关文档以及它们的重要性。

本书的另外一个特点是以“Hello World”为中心。绝大部分示例都围绕着各种“Hello World”应用，方便您快速熟悉各种核心概念。在尝试写一个操作系统之前，学会这些概念是必须的。任何比“Hello World”复杂的示例都会变成教授这些概念路上的拦路虎，使得动手编写一个操作系统的准备时间变长。

让我们开始吧。通过这本书，我希望可以提供足够的基础知识，为您打开一扇理解其他学习材料的大门。本书对于那些刚刚完成首个C/C++课程的学生最有裨益。想象一下，向未来的雇主展现您已经在打造一个操作系统了，是多么酷啊。

## 准备工作

- 电路的基本知识：
  - 电流的基本概念：原子，电子，质子，中子，电流
  - 欧姆定律

    如果您对这些概念一无所知，您可以在这里快速学习：<http://www.allaboutcircuits.com/textbook/>，阅读其中的第一章和第二章。
- C语言编程。特别是：
  - 变量与函数的声明与定义
  - `while`与`for`循环
  - 指针与函数指针
  - C语言基础算法与数据结构
- Linux基础：
  - 了解如何用命令行浏览文件夹
  - 了解如何调用带选项的命令
  - 了解如何通过管道把输出传给另一个程序
- 盲打。既然我们要用Linux，盲打会帮上大忙。我知道打字速度与解决问题没关系，但是您的打字速度至少要足够快，不要让它成为学习路上的拦路虎。

总之，我假设读者具备C语言基础知识，并且会使用IDE编译和执行程序。

## 您在本书中会学到什么？

- 如何通过阅读硬件规格表从头开始编写操作系统。在现实世界里，在Google上您没有办法立即找到答案。
- 独立地编写代码。复制粘贴代码是没有意义的。自己动手解决自己的问题才能学到东西。我们提供了一些范例帮您起步，但是绝大部分问题都需要您来解决。努力尝试了以后，您可以比对线上的解决方案。
- 从硬件到软件，计算机的每一层是如何相互联系起来的整体情况。
- 如何把Linux作为开发环境，以及如何使用常见工具进行底层开发。
- 应用程序的结构如何，使得操作系统可以执行它。
- 如何使用gdb和QEMU调试直接运行在硬件上的程序
- 用纯C语言在x86_64裸机上进行链接和加载。没有标准库。没有运行时的开销。

## 这本书不会覆盖

- 电气工程：本书讨论了一些电子与电气工程学的概念，但也仅限于解释清楚软件是如何运行在裸机上的程度。
- 如何使用Linux或是任意操作系统类型的书籍：即使Linux被用作开发环境以及作为展示操作系统高级概念的媒介，但它并不是本书的焦点。
- Linux内核开发：市面上已经有了许多这方面的优质书籍。
- 关注于算法的操作系统书籍：本书更关注于实际的硬件平台——Intel的x86_64——以及如何编写一个充分利用硬件平台操作系统支持功能的操作系统。

## 本书的组织结构

第一部分提供了学习操作系统的基础。

- 第一章简要阐释了领域文档的重要性。文档对于学习体验来说至关重要，所以值得用一个章节描述。
- 第二章解释了从硬件到软件的各个抽象层级。意在揭示代码在物理层面是如何运行的内在机理。
- 第三章描述了计算机的一般架构，而后引入了一个示例计算机模型，您会用它来写一个操作系统。
- 第四章通过使用Intel手册介绍了x86汇编语言，包括了常用指令。这一章给出了高级语法如何对应底层汇编的详细示例，教会您轻松阅读生成的汇编代码。调试操作系统时，读汇编代码是必须的。
- 第五章详细分析了可执行与可链接格式（ELF）。只有在二进制级别理解了程序的结构，您才可以在裸机上构建一个程序。
- 第六章介绍了gdb调试器，外加覆盖各种常用命令的大量示例。读者熟悉了gdb以后，又进一步揭示了调试器是如何工作的。这对于在裸机上构建一个可以调试的程序来说是必备知识。

第二部分展示了如何写一个引导程序（bootloader）来启动内核。因而得名“基础工作”。掌握了这一部分之后，读者可以继续学习下一部分，它可以指导您编写一个操作系统。然而如果读者不喜欢这种呈现形式，您可以去别处看看，比如OSDev的维基百科：<http://wiki.osdev.org/>

- 第七章介绍了什么是引导程序，如何用汇编语言写一个引导程序，以及如何把引导程序加载到硬件模拟器QEMU。这个过程涉及到了输入重复性的长命令，所以使用了GNU Make把重复性工作自动化、简化了项目的交互，提升了工作效率。这一章也演示了在这个领域GNU Make的用处。
- 第八章介绍了链接，解释了组合目标文件（object files）时的重分配过程。除去用汇编语言编写的引导程序以及用C语言写的操作系统，这是在裸机上构建可调试程序的最后一块拼图。

第三部分提供了如何编写一个操作系统的指南，您应当独立实现一个操作系统，并对您的产出感到骄傲。这个指南包含了对诸多必备概念更简单、更连贯的解释，范围覆盖了硬件和软件，用以实现操作系统的各个功能。如果没有这样的指南，您将花费大量时间搜集分布在各种文档和网络上的信息。而后，它提供了一个如何把概念映射到代码的计划。

## 鸣谢

谢谢您们，我亲爱的家人。谢谢您们，所有的参与者们。
